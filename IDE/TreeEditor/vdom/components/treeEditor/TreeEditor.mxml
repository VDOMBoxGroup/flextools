<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml" width="100%" height="100%" creationComplete="init()">
<mx:Script>
	<![CDATA[
		import mx.events.MoveEvent;
		import mx.controls.Image;
		import mx.events.TreeEvent;
		import vdom.events.TreeEditorEvent;
		import mx.states.AddChild;
		import mx.core.Container;
		import mx.controls.Button;
		import mx.events.DragEvent;
	//данные которые уже есть
	private var xml1:XML = 
<Structure>
	<Object ID="id_01" top="10" left="10">
		<Level Index="0">
			<Object ID="id_02"/>
			<Object ID="id_03"/>
		</Level>
		<Level Index="1">
			<Object ID="id_03"/>
			<Object ID="id_04"/>
		</Level>
		<Level Index="2">
			<Object ID="id_05"/>
			<Object ID="id_06"/>
		</Level>
		<Level Index="3">
			<Object ID="id_07"/>
			<Object ID="id_08"/>
		</Level>
		<Level Index="4">
			<Object ID="id_02"/>
			<Object ID="id_03"/>
		</Level>
		<Level Index="5">
			<Object ID="id_03"/>
			<Object ID="id_04"/>
		</Level>
	</Object>
	<Object ID="id_02" top="10" left="150">
		<Level Index="0">
			<Object ID="id_03"/>
			<Object ID="id_04"/>
		</Level>
		</Object>
	<Object ID="id_03" top="50" left="10"/>
	<Object ID="id_04" top="100" left="150"/>
	<Object ID="id_05" top="150" left="150"/>
	<Object ID="id_06" top="90" left="10"/>
	<Object ID="id_07" top="50" left="200"/>
	<Object ID="id_08" top="200" left="200"/>
</Structure>;  
 
 	private var massTreeElements:Array = new Array();
	private var massLines:Array = new Array();
	private var resizer:ResizeManager;
	private var selectedTreeEliment:String;
	private var treeElement:TreeElement = new TreeElement();
	private var canRectangle:Canvas = new Canvas();
	private var curTree:Object = new Object();
	private var canLine:Canvas = new Canvas();
	private var pnFrom:Point = new Point();
	private var blDrawLine:Boolean = false;
	
		
	
	
	
	
	private function init():void
	{
		//создаем массив с обьектами
		for each(var xmlObj:XML in xml1.children())
		{
			var obID:String = xmlObj.@ID.toXMLString();
			massTreeElements[obID] =  new TreeElement();
			//massTreeElements[obID].setStyle('backgroundColor', '#ffffff');
			massTreeElements[obID].name = xmlObj.@ID.toXMLString();
			massTreeElements[obID].x = xmlObj.@left.toXMLString();
			massTreeElements[obID].y = xmlObj.@top.toXMLString();	
			massTreeElements[obID].addEventListener(TreeEditorEvent.REDRAW , mouseHandler);	
			massTreeElements[obID].addEventListener(TreeEditorEvent.START_DRAG , startingDrag);	
			massTreeElements[obID].addEventListener(TreeEditorEvent.START_DRAW_LINE , startDrawLine);	
			massTreeElements[obID].addEventListener(TreeEditorEvent.DELETE , deleteTreeElement);	
			//massTreeElements[obID].addEventListener(TreeEditorEvent.STOP_DRAG , stopingDrag);
			massTreeElements[obID].addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);
			//
		//	massTreeElements[obID].addEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);	//
			addChild(massTreeElements[obID]);
			
		}
		drawLines();
	}
	
	// перерисовываем необходимые линии
	private function mouseHandler(trEvt:Object):void
	{
		for (var level:String in massLines)
		for(var ind1:String in massLines[level])
			for(var ind2:String in massLines[level][ind1])
				if (trEvt.ID == ind1 || trEvt.ID == ind2)
				{
				//	trace(trEvt.ID);
					 cnvLevelDown.removeChild( massLines[level][ind1][ind2]);
					 massLines[level][ind1][ind2] = new TreeVector(massTreeElements[ind1], massTreeElements[ind2], level);
					 cnvLevelDown.addChild(massLines[level][ind1][ind2]);
				}
	}
	
	
	// рисуем линии
	private function drawLines():void
	{
		for each(var xmlObj:XML in xml1.children())
		{
			var obID:String = xmlObj.@ID.toXMLString();
			
			//создаем массив с Направляющими между обьектами
			for each(var xmlLavel:XML in xmlObj.children())
			{
				var level:String = xmlLavel.@Index.toXMLString();
				// mass of levels where  level  consist of numbers betvin 0-9
				if (!massLines[level]) massLines[level] = new Array();
				if (!massLines[level][obID]) massLines[level][obID] = new Array();
				
				for each(var xmlLavelObj:XML in xmlLavel.children())
				{
					var toObjID:String = xmlLavelObj.@ID.toXMLString();
					if (massLines[level][obID][toObjID])
						removeChild( massLines[level][obID][toObjID]);
					massLines[level][obID][toObjID] = new TreeVector(massTreeElements[obID], massTreeElements[toObjID], level);
					cnvLevelDown.addChild(massLines[level][obID][toObjID]);
				}
			}
		}
	}
	/******
	При выделении темнее
	на двойной щелчек скрываться /разкрываться
	когда  соединяешь, стрелка за мышкой
	цвет по текущему уровню
	Баг верхнего угла
	
	*/
	
	private function startingDrag(evt:TreeEditorEvent):void
	{
		
		var rect:Rectangle = new Rectangle(this.x, this.y, width, height);
		
		
		canRectangle.x = evt.currentTarget.x;
		canRectangle.y = evt.currentTarget.y;
		canRectangle.graphics.lineStyle(3, 0.5, 0.2, false, LineScaleMode.NONE, CapsStyle.SQUARE, JointStyle.MITER);
		canRectangle.graphics.beginFill(0x555555,  0);
		canRectangle.graphics.drawRect(0, 0, evt.currentTarget.width, evt.currentTarget.height);
		canRectangle.addEventListener(MouseEvent.MOUSE_UP, stopingDrag);
		canRectangle.startDrag(false, rect);
		addChild(canRectangle);
	}
	
	private function stopingDrag(trEvt:MouseEvent):void
	{
		canRectangle.stopDrag();
		curTree.x = canRectangle.x;
		curTree.y = canRectangle.y;
		canRectangle.graphics.clear();
		canRectangle.removeEventListener(MouseEvent.MOUSE_UP, stopingDrag);
		mouseHandler(curTree);
		removeChild(canRectangle);
	}
	
	// Кликнули по обьекту, выделяем его
	private function mouseDownHandler(evt:MouseEvent):void
	{
		
		// проводим линию
		if(blDrawLine){
			var fromObj:String = curTree.ID.toString();
			var toObj:String = evt.currentTarget.ID.toString();
			var necessaryLevel:String = '0';
			//trace('blDrawLine == true: '+ evt.currentTarget.ID.toString());
			//              СОЗДАТЬ ЗАРАНЕЕ !!!    
			if(!massLines[necessaryLevel]) 
				massLines[necessaryLevel] = new Array();
			
			if(!massLines[necessaryLevel][curTree.ID.toString()]) 
				massLines[necessaryLevel][curTree.ID.toString()] = new Array();
			
			// может эта линия уже есть?
			for (var level:String in massLines)
				for (var frsTrElem:String in massLines[level])
					for (var sknTrElem:String in massLines[level][frsTrElem])
						if((frsTrElem == fromObj && sknTrElem == toObj ) ||
							(frsTrElem == toObj && sknTrElem ==  fromObj ))
								return;
					
						
			massLines[necessaryLevel][curTree.ID.toString()][evt.currentTarget.ID.toString()] 	= 
			new TreeVector(massTreeElements[curTree.ID], massTreeElements[evt.currentTarget.ID], necessaryLevel);
			
			cnvLevelDown.addChild(massLines[necessaryLevel][curTree.ID.toString()][evt.currentTarget.ID.toString()]);
				
			
		}else{
			trace('blDrawLine == false');
		};

		// выделяем необходимый
		curTree.alpha = 1;
		curTree = evt.currentTarget;
		curTree.alpha = 0.5;
	}
	
	private function deleteTreeElement(trEvt:TreeEditorEvent):void
	{
		// удаляем "связи" 
		for (var level:String in massLines)
		for(var ind1:String in massLines[level])
			for(var ind2:String in massLines[level][ind1])
				if (trEvt.ID == ind1 || trEvt.ID == ind2)
				{
					 cnvLevelDown.removeChild( massLines[level][ind1][ind2]);
					 delete massLines[level][ind1][ind2];
				}
		// удаляем сам обьект
		removeChild(massTreeElements[trEvt.ID]);
		delete massTreeElements[trEvt.ID];
	}
	
	private function startDrawLine(trEvt:TreeEditorEvent):void
	{
	//	canLine = new Canvas()
		addChild(canLine); //для рисования связывающей линии
		addEventListener(MouseEvent.MOUSE_MOVE, drLine);
		
		pnFrom.x = trEvt.currentTarget.x;
		pnFrom.y = trEvt.currentTarget.y;
		blDrawLine = true; //говорим что рисуем линию
//		trEvt.stopPropagation();
		addEventListener(MouseEvent.MOUSE_DOWN, stopDrawLine);
		drLine(new MouseEvent(MouseEvent.MOUSE_OVER));
	}
	
	private function stopDrawLine(msEvt:MouseEvent):void
	{
		removeEventListener(MouseEvent.MOUSE_MOVE, drLine);
		removeEventListener(MouseEvent.MOUSE_DOWN, stopDrawLine);
		canLine.graphics.clear(); 
		removeChild(canLine);
		blDrawLine = false;  //говорим что НЕ рисуем линию
	}
	private function drLine (mEvt:MouseEvent):void
	{
		canLine.graphics.clear();
		canLine.graphics.lineStyle(1, 1, 1, false, LineScaleMode.NONE, CapsStyle.SQUARE, JointStyle.MITER);
		canLine.graphics.moveTo(pnFrom.x, pnFrom.y);
		
		var dX:int = 2;
		var dY:int = 2;
		var tX:int = mouseX - pnFrom.x;
		var tY:int = mouseY - pnFrom.y;
		
		if((tX>0) && (tY>0) )
		{
			dX = -3;
			dY = -3
		}
		canLine.graphics.lineTo(mouseX + dX, mouseY + dY);
	}
	
	]]>
</mx:Script>
<mx:Canvas id="cnvLevelTop"/>
<mx:Canvas id="cnvLevelDown"/>
	

</mx:Canvas>