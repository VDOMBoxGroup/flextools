<?xml version="1.0" encoding="utf-8"?>
<mx:HTML xmlns:mx="http://www.adobe.com/2006/mxml" 
	location="libs/ckeditor/_samples/fullpage.html"
	creationComplete="init()" width="100%" height="100%"
	htmlDOMInitialize="html1_htmlDOMInitializeHandler(event)">
	<mx:Script>
		<![CDATA[
			private var instancesInitialized 	: Boolean;
			
			public static const MAX_IMAGE_WIDTH : Number = 500;
			
			public static const EVENT_WYSIWYG_SAVE_COMBINATION_CLICKED	: String = "EVENT_WYSIWYG_SAVE_COMBINATION_CLICKED"; 
			public static const EVENT_WYSIWYG_HTTP_IMAGE_LOADED			: String = "EVENT_WYSIWYG_HTTP_IMAGE_LOADED";
			
			private function init():void
			{
				this.addEventListener(KeyboardEvent.KEY_UP,		onKeyboardKeyUp);
				this.addEventListener(KeyboardEvent.KEY_DOWN,	onKeyboardKeyDown);
			}
			
			private function onKeyboardKeyDown(keyEvent:KeyboardEvent):void
			{
				if (keyEvent.ctrlKey && !(keyEvent.keyCode == Keyboard.C || keyEvent.keyCode == Keyboard.V) ) {
					keyEvent.preventDefault();
				}
			}
			
			private function onKeyboardKeyUp(keyEvent:KeyboardEvent):void
			{
				switch(keyEvent.keyCode)
				{
					case (Keyboard.S):
					{
						if (keyEvent.ctrlKey) {
							this.dispatchEvent(new Event(EVENT_WYSIWYG_SAVE_COMBINATION_CLICKED));
						}
						break;
					}
					default:
					{
						break;
					}
				}
			
			}
			
			public function setHTML( value : String ) : void
			{
				if (!instancesInitialized) {
					return;
				}
				domWindow.CKEDITOR.instances.editor1.setData(value);
			}
			
			public function getHTML(showPageToc:Boolean = false) : String
			{
				var editorData	: String;
				var patternHead	: RegExp;
				var htmlTxt		: String;
				
				patternHead = /<[ ]*head[ ]*(>|\/[ ]*>)/i;
				
				editorData = instancesInitialized ? domWindow.CKEDITOR.instances.editor1.getData() : "";
				htmlTxt = editorData;
				
				if (editorData.search(patternHead) == -1) 
				{
					htmlTxt = getHtmlSourceTxt(editorData, showPageToc);
						
				}
				
				return htmlTxt;
			}
			
			private function getHTML_toSave():void
			{
				// TODO: перенести из VdomHelpEditor:
				// resetImagesPath();
			}
			
			private static function getHtmlSourceTxt(bodyContent : String, showPageToc:Boolean = false) : String
			{
				var metaTeg		: String;
				var cssTeg		: String;
				var scriptTeg	: String;
				var titleTeg	: String;
				var htmlTxt		: String = "";
				
				metaTeg = "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />";
				cssTeg = "<link rel='stylesheet' href='app-storage:/main.css' type='text/css'></link>";
				scriptTeg = "<script src='app-storage:/searchhi_slim.js'></script>";
				titleTeg = "<title></title>";
				
				htmlTxt = "<html>" + "\n" + 
								"<head>" + "\n" +
									metaTeg + "\n" +
									cssTeg + "\n" +
									scriptTeg + "\n" +
								"</head>" + "\n" +
								"<body>" + "\n" +
									bodyContent + "\n" +
								"</body>" + "\n" +
							"</html>";
				
				if (showPageToc) {
					return htmlTxt;
				}
				return getHTMLWithoutPageToc(htmlTxt);
				
			}
			
			private static function getHTMLWithoutPageToc(value:String) : String 
			{
				var xml			:XML = new XML(value);
				var ulClass		: String = "";
				var divClass	: String = "";
				var linkClass	: String = "";
				
				// delete old variant of toc ...
				for each (var xmlDiv:XML in xml.body.div) {
					
					divClass = String(xmlDiv.@["class"]);
					
					if (divClass.indexOf(PageToc.TOC_BY_HEADERS_CLASS) >= 0 || 
						divClass.indexOf(PageToc.TOC_BY_PAGES_CLASS) >= 0 ) {
						
						delete xmlDiv.parent().children()[xmlDiv.childIndex()];
					}
					
				}
				// ... delete old variant of toc
				
				for each (var xmlUl:XML in xml.body.ul) {
					
					ulClass = String(xmlUl.@["class"]);
					
					if (ulClass.indexOf(PageToc.TOC_BY_HEADERS_CLASS) >= 0 || 
						ulClass.indexOf(PageToc.TOC_BY_PAGES_CLASS) >= 0 ) {
						
						delete xmlUl.parent().children()[xmlUl.childIndex()];
						break;
					}
					
				}
				
				for each (var xmlLink:XML in xml.body..a) {
					
					linkClass = String(xmlLink.@["class"]);
					
					if (linkClass.indexOf(PageToc.ANCOR_CLASS) >= 0) {
						
						delete xmlLink.parent().children()[xmlLink.childIndex()];
					}
					
				}
				
				return xml.toXMLString();
			}
			
			protected function html1_htmlDOMInitializeHandler(event:Event):void
			{
				instancesInitialized = true;
			}
			
			public static function getNewPageContent(aPageTitle:String) : String
			{
				
				return getHtmlSourceTxt("<h1>"+aPageTitle+"</h1>");
			}
			
			public function generateLinkToPage(aPageName:String, aPageTitle:String) : void
			{
				var strHref:String = "<a href=\""+ aPageName +"\">"+ aPageTitle +"</a>";
				
				Clipboard.generalClipboard.setData(ClipboardFormats.HTML_FORMAT, strHref);
			}
			
			public function resetImagesPath() : void
			{
				var xmlContent : XML = XML(getHTML());
				var resourcesList	: XMLList	= xmlContent..img;
				
				for each (var xmlImg:XML in resourcesList)
				{
					var newPath : String;
					var imgSrc : String = String(xmlImg.@src);
					
					if ( !imgSrc || imgSrc.indexOf("app-storage:/resources") >= 0 || imgSrc.indexOf("app-storage:\resources") >= 0 ) // resource exists
						continue;
					
					if ( imgSrc.indexOf("http://") >= 0 || imgSrc.indexOf("https://") >= 0 ) // image from http
					{
						newPath = loadHttpImg(imgSrc);
					} else 
					{
						newPath = copyImg(removeWhiteSpacingAfterFileName(imgSrc)); // image from file system
					}
					
					if (!newPath)
						delete xmlImg.parent().children()[xmlImg.childIndex()];
					else
						xmlImg.@src = newPath;
					
					setHTML(xmlContent.toString());
				}
			}
			
			private function removeWhiteSpacingAfterFileName(path:String) : String
			{
				path = path.substring(0 , path.lastIndexOf(".")) +
					path.substring(path.lastIndexOf("."), path.length).replace(" ", "");
				
				return path;
			}
			
			private function copyImg(aImageOldSrc_str:String) : String
			{
				var targetPath : String;
				var imgFile : File;
				var newImgFile : File;
				
				imgFile = new File(aImageOldSrc_str);
				
				if (!imgFile.exists)
					return null;
				
				targetPath = "resources/" + VdomHelpEditor.generateFileName(aImageOldSrc_str, imgFile);
				newImgFile = File.applicationStorageDirectory.resolvePath(targetPath);
				
				
				if ( !newImgFile.exists )
					imgFile.copyTo(newImgFile);
				
				return newImgFile.url;
			}
			
			private function loadHttpImg(aImageOldSrc_str:String) : String
			{
				var targetPath : String;
				var urlRequest : URLRequest;
				var urlLoader : URLLoader;
				var file : File;
				
				
				targetPath = "resources/" + VdomHelpEditor.generateFileName(aImageOldSrc_str);
				urlRequest = new URLRequest(aImageOldSrc_str);
				urlLoader = new URLLoader();
				
				urlLoader.dataFormat = URLLoaderDataFormat.BINARY;
				urlLoader.addEventListener(Event.COMPLETE, urlLoader_complete);
				urlLoader.addEventListener(IOErrorEvent.IO_ERROR, urlLoader_error);
				urlLoader.addEventListener(SecurityErrorEvent.SECURITY_ERROR, urlLoader_error);
				urlLoader.load(urlRequest);
				
				file = File.applicationStorageDirectory.resolvePath(targetPath);
				
				function urlLoader_complete(evt:Event) : void {
					var fileStream : FileStream;
					
					fileStream = new FileStream();
					try {
						fileStream.open(file, FileMode.WRITE);
						fileStream.writeBytes(urlLoader.data);
						fileStream.close();
						
						this.dispatchEvent(new Event(EVENT_WYSIWYG_HTTP_IMAGE_LOADED));
						
					} catch ( error : IOError ) {
						trace("!!! Error Write !!! \n" + error.message +"\n");
						return;
					}
				}
				
				function urlLoader_error(evt:Event) : void {
					trace("!!! Error Loading file !!! \n");
				}
				
				return file.url;
			}
			
			public function resetImagesWidth():void
			{
				// TODO: set image width <= MAX_IMAGE_WIDTH
				/*
					1) width задана: <= MAX_IMAGE_WIDTH -> OK,
								 > MAX_IMAGE_WIDTH -> width = 500;
				
				 	2) width НЕ задана: то же самое, только смотрим размерность файла. 
				*/
				
			}
		]]>
	</mx:Script>
</mx:HTML>
